# 개념

## 엔티티 (Entity)
- 도메인 모델 생성 시 사용되는 패턴
- 도메인 내 대상/개념
  - (1) 고유한 식별자(`id`)로 개별적으로 구분됨
  - (2) 시간의 흐름에 따라 상태가 변경되는 생명주기를 가짐

## 도메인 모델 패턴
- 도메인/비즈니스 로직을 구성하는 아키텍처 패턴의 한 가지
- 도메인 모델의 `속성`과 `행위`를 모두 포함하는 도메인의 오브젝트 모델
- 오브젝트 모델 -> 복잡한 연관 관계, 커스텀 속성, 상속 등 사용 가능

## 값 객체 (Value Object)
- 도메인 모델에서 식별자가 필요하지 않고, 속성/값으로만 구별되는 오브젝트
- 엔티티가 너무 많은 책임을 가지는 것을 방지하고, 특정 속성 관련 행위를 분리해서 엔티티를 더 집중된 상태로 유지하게 함
- 원시 타입보다 도메인 개념을 더 명시적으로 나타내서 모델의 명확서을 높임
- 생성 이후에 상태가 변하지 않고, 변경이 필요하면 새로운 객체로 교체함
- 풍부한 기능을 가짐
- 자체 유효성 검사 가능

## 원시 타입을 객체로 교체 - 리팩토링
- 원시 타입의 남용을 개선하고 코드의 명시성과 안정성을 높이는 리팩토링 방법
- 값 객체는 도메인 모델의 핵심 구성 요소로, 값 그 자체의 의미를 담아내고 불변성, 동등성 등의 도메인 로직을 포함하여 설계하는 방식

## 도메인 모델 패턴의 두 가지 스타일
- 단순 도메인 모델 (Simple Domain Model): DB 설계와 유, 테이블에 대해 하나의 도메인 오브젝트
- 풍성한 도메인 모델 (Rich Domain Model): 상속, 전략, GoF 디자인 패턴, 연관 관계 등 복잡한 로직에 적합하지만 DB 매핑이 어려울 수 있음

## 아키텍처
- 시스템의 기본적인 구조를 정의함
- 시스템의 중요한 품질 속성에 큰 영향을 미침
- 설계 결정의 기반이 되는 핵심적인 개념
- 기본 구성 요소와 상호 관계, 제약 조건, 원칙 등을 포함함

## 계층형 아키텍처 (Layered Architecture)
- 서브 시스템을 계층(Layer)으로 구조 하는 아키텍처 스타일
- 계층은 사용 관계로 연결됨
- 사용 관계는 일반적으로 단방향이어야 한다는 핵심 제약이 존재
  - 상위 계층이 하위 계층의 서비스를 사용하는 하향식 흐름을 가짐
- 각 계층이 하위 계층의 내부 동작 방식을 알지 못하고 제한된 인터페이스만 사용함 (계층 격리 Layers of Isolation)
  - 어떤 Layer의 변경이 다른 Layer의 컴포넌트에게 가능한 영향을 주지 않도록 해야함

## 3 or 4계층 아키텍처
- Presentation -> (Application Service -> Domain) -> Infra


## 헥사고날 아키텍처
- 계층형 아키텍처의 단방형 비대칭 구조가 아닌, 대칭형(symmetric) 아키텍처
- 위, 아래, 좌, 우가 아닌 애플리케이션 내부와 외부 세계라는 대칭 구조를 가짐


### 헥사곤의 내부
- 쉽게 변하지 않는, 중요한 도메인 로직을 담은 코어 애플리케이션
  - 도메인 로직을 가진 트랜잭션 스크립트
  - 애플리케이션 서비스와 도메인 모델 패턴을 따라서 만든 도메인


### 헥사곤의 외부
- 헥사곤과 상호작용(interaction)하는 모든 것 - `액터(Actor)`
- 사용자, 브라우저, CLI 명령, 기계, 다른 시스템 등
- 운영 환경, DB, 메시징 시스템, 메일 시스템, 원격 서비스
- 테스트


### 헥사고날 아키텍처의 특징과 혜택
- 테스팅. 운영 시스템에 연결하지 않고 애플리케이션 테스트
- 애플리케이션과 상호작용하는 액터가 바뀌더라도 다시 빌드하지 않고 테스트
- UI 디테일이나 기술 정보가 도메인 로직 안으로 노출되지 않도록 보호함. 반대도 동일
- 컴포넌트를 각각 개발하고 연결하는 방식으로 큰 시스템을 분리할 수 있음
- 시간이 지나면서 외부 연결을 다른 것으로 변경 가능
- 기술 요소를 제거했기에 도메인 설계에 집중 가능함


### 헥사곤을 부르는 여러가지 이름
- 헥사곤
- `애플리케이션`
- 앱(App)
- 코어 시스템


### 포트 (Port)
- 애플리케이션이 외부 세계와 의도(intention)를 가지고 상효작용 하는 아이디어를 캡쳐한 것
- 단순히 데이터를 주고받는 것이 아니라, 명확한 목적성과 방향을 가지고 외부와 연결됨
- 애플리케이션이 정의한 인터페이스로 만들어짐


### 인터페이스
- Lillipop: Provided Interface
- Socket: Required Interface


### 기능 제공 인터페이스 (Provided Interface)
- 애플리케이션이 가지고 있는 기능을 외부 액터가 사용할 수 있게 노출한 것
- Primary Actor는 Provided Interface 이용


### 기능 요구 인터페이스 (Required Interface)
- 애플리케이션이 직접 가지고 있지 않은 기능이 있는 경우 외부의 Actor와 소통이 필요함. 이때 애플리케이션이 노출하는 포트를 의미함
- 외부 Actor를 Secondary Actor라고 부름


### 어댑터 (Adapter)
- 애플리케이션의 포트를 액터가 직접 연결할 수 없다면, 인터페이스의 변환을 위함 어댑터를 도입


### 헥사고날 아키텍처의 비대칭성
- 애플리케이션이 제공하는 기능을 사용하는 액터와 이를 위한 어댑터
  - primary actor, primary adapter
  - driving actor, driving adapter
  

- 애플리케이션이 동작하는데 필요한 기능을 제공하는 액터와 이를 위한 어댑터
  - secondary actor, secondary adapter
  - driven actor, driven adapter


### 오해1: 애플리케이션 내부에 도메인 계층을 만들어야 한다?
- 헥사고날 아키텍처는 애플리케이션 내부 구현에 대한 원칙이나 요구사항이 없음
  - 스파게티 코드로 만들어도 OK
- 헥사고날 아키텍처는 클린 아키텍처, 어니언 아키텍처가 아님


### 오해2: 헥사고날 아키텍처 패키지 구조를 따라야 한다?
- 헥사고날 아키텍처가 요구하는 패키지 구조는 없음
- 애플리케이션과 어댑터 패키지를 분리하는 것은 바람직함
- 포트를 구분된 패키지에 두는 것을 권장


### 오해3: 포트는 UseCase라는 접미사를 사용한다?
- 포트의 의도를 담은 이름을 사용하면 됨


### 오해4: 애플리케이션에는 도메인 모델만 넣고 JPA 엔티티 등은 어댑터에 둬야 한다?
- 애플리케이션 코드와 포트 인터페이스가 외부 기술에 의존하지 않으면 됨


### 사실: 헥사고날 아키텍처가 요구하는 것
- 애플리케이션은 모든 외부와의 상호작용을 위해 `provided interface`와 `required interface`를 정의함
- 애플리케이션과 상호작용 하는 액터는 런타임에 구성되어야 함
- 애플리케이션은 액터에 대한 코드 의존성을 가지면 안됨
- 액터는 정의된 포트를 통해서만 연결되어야 함
- 포트의 인터페이스는 기술 의존성을 가지지 않음


### 헥사고날과 도메인 모델 패턴을 적용한 대칭형 계층 구조
- 도메인 계층
- 애플리케이션 계층
- 어댑터 계층
- 외부에서 내부로 향하는 일종의 계층 구조
- `코드의 의존 방향은 내부로만 향함: [어댑터] -> [애플리케이션] -> [도메인]`
- 단, 사용의 흐름은 비대칭적


## 엔티티 식별자
- 고유성: 두 개의 엔티티가 같은 값을 가지면 안됨
- 불변성: 한 번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안됨
  - 참조 정합성을 훼손하고, 연관관계를 깨뜨림
- 비즈니스적인 의미로부터 디커플링 되는 것이 나음
  - 자연 키 대신 인조 키(대리 키) 사용
- 